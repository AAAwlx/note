### **重定位表（Relocation Table）的结构详解**

重定位表是 ELF 文件（目标文件 `.o` 或共享库 `.so`）中的关键数据结构，用于指导**链接器**或**动态链接器**修正代码和数据中的地址引用。其核心作用是解决编译时地址不确定的问题，确保程序在链接后或加载到内存后能正确运行。

---

## **1. 重定位表的存储位置**
• **目标文件（`.o`）**：  
  • `.rel.text`：代码段（`.text`）的重定位表（修正函数调用等）。  
  • `.rel.data`：数据段（`.data`）的重定位表（修正全局变量引用等）。  
• **可执行文件/共享库**：  
  • `.rela.dyn`：动态重定位表（修正绝对地址引用）。  
  • `.rela.plt`：PLT（过程链接表）的重定位表（修正动态库函数调用）。  

---

## **2. 重定位表的基本结构**
重定位表由一系列条目（Entry）组成，每个条目是一个固定大小的结构体（`Elf64_Rela` 或 `Elf32_Rel`），包含以下字段：

### **(1) `Elf64_Rela`（带附加值的重定位条目）**
```c
typedef struct {
    Elf64_Addr    r_offset;  // 需要修正的地址（相对于所在段的偏移）
    Elf64_Xword   r_info;    // 符号索引和重定位类型（低32位为类型，高32位为符号索引）
    Elf64_Sxword  r_addend;  // 附加的常量值（用于调整最终地址）
} Elf64_Rela;
```

### **(2) `Elf32_Rel`（不带附加值的重定位条目）**
```c
typedef struct {
    Elf32_Addr    r_offset;  
    Elf32_Word    r_info;    // 符号索引和重定位类型
} Elf32_Rel;
```

---

## **3. 重定位条目的字段解析**
| **字段**       | **说明**                                                                 |
|----------------|--------------------------------------------------------------------------|
| **`r_offset`** | 需要修正的地址（相对于所在段的偏移量）。<br>例如：`call foo` 指令在 `.text` 段中的偏移量。 |
| **`r_info`**   | 分为两部分：<br>- **低8位**：重定位类型（如 `R_X86_64_PC32`）。<br>- **高24/56位**：符号在符号表中的索引（关联的符号）。 |
| **`r_addend`** | 附加的调整值（通常为0，某些架构需要）。                                   |

---

## **4. 重定位类型（Relocation Type）**
不同平台（如 x86、ARM）有各自的重定位类型，常见的有：

### **(1) x86-64 常见类型**
| **类型**               | **用途**                                                                 | **计算公式**                          |
|------------------------|--------------------------------------------------------------------------|---------------------------------------|
| `R_X86_64_32`          | 修正绝对地址（如全局变量）。                                             | `修正值 = Symbol地址 + Addend`         |
| `R_X86_64_PC32`        | 修正相对偏移（如 `call` 指令）。                                          | `修正值 = Symbol地址 - 当前指令地址 + Addend` |
| `R_X86_64_JUMP_SLOT`   | 动态库函数跳转（通过 PLT/GOT）。                                         | 由动态链接器在运行时填充               |
| `R_X86_64_GLOB_DAT`    | 修正全局数据引用（如 GOT 表中的变量地址）。                              | `修正值 = Symbol地址`                  |

### **(2) ARM 常见类型**
| **类型**               | **用途**                                                                 |
|------------------------|--------------------------------------------------------------------------|
| `R_ARM_ABS32`          | 绝对地址修正（类似 `R_X86_64_32`）。                                    |
| `R_ARM_REL32`          | 相对偏移修正（类似 `R_X86_64_PC32`）。                                   |
| `R_ARM_JUMP_SLOT`      | 动态库函数跳转。                                                        |

---

## **5. 重定位表示例分析**
### **(1) 目标文件（`.o`）中的重定位表**
假设有以下代码：
```c
// main.c
extern int global_var;
void foo();
int main() {
    foo();
    return global_var;
}
```
编译后生成 `main.o`，其重定位表可能如下：
```
.rel.text 段：
Offset   Type           Symbol       Addend
0x01     R_X86_64_PC32  foo          0xFC
0x07     R_X86_64_32    global_var   0
```
• **`call foo`**：  
  • `Offset=0x01`：`call` 指令在 `.text` 段的偏移量。  
  • `Type=R_X86_64_PC32`：需计算相对偏移。  
  • `Symbol=foo`：关联符号表中的 `foo`。  
  • `Addend=0xFC`：调整值（由指令长度决定）。  

• **`mov [global_var]`**：  
  • `Offset=0x07`：`mov` 指令的偏移量。  
  • `Type=R_X86_64_32`：需修正为绝对地址。  

### **(2) 动态链接重定位表（`.rela.plt`）**
动态库函数（如 `printf`）的重定位条目：
```
.rela.plt 段：
Offset   Type               Symbol     Addend
0x4000   R_X86_64_JUMP_SLOT printf    0
```
• **`printf`**：  
  • `Offset=0x4000`：GOT 表中的条目地址。  
  • `Type=R_X86_64_JUMP_SLOT`：动态链接器需填充 `printf` 的实际地址。  

---

## **6. 重定位表的工作流程**
### **(1) 静态链接阶段**
1. **合并目标文件**：链接器扫描所有 `.o` 文件的符号表和重定位表。  
2. **分配最终地址**：为所有段（`.text`、`.data`）分配虚拟地址（如 `.text` 从 `0x400000` 开始）。  
3. **修正地址引用**：  
   • 根据重定位表中的 `Offset` 找到需修正的指令或数据。  
   • 按 `Type` 计算新地址（绝对或相对），并写入到 `Offset` 指定的位置。  

### **(2) 动态链接阶段**
1. **加载共享库**：动态链接器（如 `ld-linux.so`）读取 `.rela.dyn` 和 `.rela.plt`。  
2. **填充 GOT/PLT**：  
   • 将动态库函数（如 `printf`）的地址填入 GOT 表。  
   • 程序通过 PLT 跳转到 GOT 中的地址。  

---

## **7. 如何查看重定位表？**
### **(1) 目标文件（`.o`）**
```bash
readelf -r main.o       # 查看重定位表
objdump -r main.o       # 简化的重定位表
```

### **(2) 可执行文件/共享库**
```bash
readelf -r program      # 查看动态重定位表
objdump -R program      # 显示动态重定位条目
```

### **(3) 示例输出**
```
Relocation section '.rela.text' at offset 0x200:
  Offset     Info     Type           Symbol      Addend
  00000001  00000201 R_X86_64_PC32   foo         FFFFFFFC
  00000007  00000301 R_X86_64_32     global_var  00000000
```

---

## **8. 总结**
• **重定位表的结构**：  
  • `r_offset`：需修正的地址。  
  • `r_info`：符号索引和重定位类型。  
  • `r_addend`：附加调整值。  
• **核心作用**：  
  • 静态链接：修正目标文件中的地址引用。  
  • 动态链接：运行时填充 GOT/PLT 表。  
• **关键类型**：  
  • `R_X86_64_PC32`：相对偏移修正（函数调用）。  
  • `R_X86_64_32`：绝对地址修正（全局变量）。  
  • `R_X86_64_JUMP_SLOT`：动态库函数跳转。  

重定位表是程序从“编译时不确定地址”到“运行时正确执行”的桥梁！ 🌉
### **以 `call foo()` 为例详解重定位表的作用**

#### **1. 编译阶段：生成目标文件（`.o`）**
当编译器处理以下代码时：
```asm
; main.c
call foo   ; 临时地址为 0x00000000（编译器假设代码从地址0开始）
```
• **符号表（`.symtab`）**：  
  • `foo` 被标记为 **未定义符号（UND）**，因为其定义在其他文件（如 `utils.o`）。  
  • `main` 被标记为 **已定义符号**（位于 `.text` 段偏移 `0x00`）。  

• **重定位表（`.rel.text`）**：  
  | Offset（偏移） | Type（类型）       | Symbol（符号） | Addend（附加值） |  
  |---------------|--------------------|----------------|------------------|  
  | `0x01`        | `R_X86_64_PC32`    | `foo`          | `-4`             |  

  • **`Offset=0x01`**：`call` 指令的操作数部分在 `.text` 段中的偏移量（`call` 指令占 5 字节，操作数从第 2 字节开始）。  
  • **`Type=R_X86_64_PC32`**：需计算 **相对偏移**（PC-relative）。  
  • **`Symbol=foo`**：需要修正为符号 `foo` 的地址。  
  • **`Addend=-4`**：x86 架构下 `call` 指令的修正调整值（指令长度相关）。  

#### **2. 链接阶段：合并目标文件并修正地址**
链接器完成以下操作：
1. **合并 `.text` 段**：  
   • 假设 `main.o` 的 `.text` 段被分配到最终地址 `0x400100`，`utils.o` 的 `foo` 函数被分配到 `0x400200`。  
2. **计算 `call foo` 的修正值**：  
   • **公式**：  
     ```
     修正值 = Symbol地址（foo） - 当前指令地址（call的下一条指令） + Addend
             = 0x400200 - (0x400100 + 5) + (-4)
             = 0x400200 - 0x400105 - 4
             = 0xFB
     ```  
   • **修正后的指令**：  
     ```asm
     call 0xFB  ; 相对跳转到 foo（实际跳转地址 = 0x400105 + 0xFB = 0x400200）
     ```

#### **3. 关键点总结**
• **重定位表的本质**：  
  记录 **哪些指令需要修正**（通过 `Offset`）和 **如何修正**（通过 `Type` 和 `Symbol`）。  
• **相对偏移 vs 绝对地址**：  
  • `R_X86_64_PC32`：用于函数调用等需要 **位置无关代码（PIC）** 的场景。  
  • `R_X86_64_32`：用于全局变量等需要 **绝对地址** 的场景。  
• **动态链接的扩展**：  
  如果是动态库函数（如 `call printf`），重定位类型会变为 `R_X86_64_JUMP_SLOT`，由动态链接器通过 PLT/GOT 机制在运行时解析。

#### **4. 验证工具**
```bash
objdump -d main.o        # 查看 call foo 的临时机器码（操作数为0x00000000）
objdump -d program       # 查看修正后的 call 指令（操作数已变为0xFB）
readelf -r main.o        # 查看重定位表条目
```

通过重定位表，链接器将看似无效的 `call 0x00000000` 转变为正确的 `call 0xFB`，确保程序跳转到 `foo` 的真实地址！ 🎯