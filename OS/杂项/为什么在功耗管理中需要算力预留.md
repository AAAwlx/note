在 CPU 频率调控（如 Linux 的 schedutil governor）中设计 算力预留（20% 余量） 主要基于以下几个关键原因，涉及性能、稳定性和能效的平衡：

应对突发负载（Burst Workloads）

问题：任务负载可能突然增加（如中断处理、短时高优先级任务），若 CPU 频率已满载（100% 利用率），会导致任务延迟或卡顿。

解决：预留 20% 算力（即 util/max=0.8 时升至最高频），为突发负载提供缓冲。

示例：  

当 util=800（max=1024），频率升至 max_freq（如 2.0 GHz）。  

若突然新增负载使 util 升至 900，仍有 10% 的算力余量（1024-900=124）可临时应对，避免性能骤降。

避免频率震荡（Frequency Oscillations）

问题：若频率在 util=100% 时才升至最高，微小负载波动（如 util 在 990~1024 间跳动）会导致频率频繁切换，增加功耗和延迟。

解决：通过临界点 util=80% 提前升频，使频率调整更平滑。

效果：  

负载在 80%~100% 间波动时，频率保持 max_freq，减少不必要的调频操作。

补偿调度和调频的延迟

问题：从检测到负载变化到实际调整频率存在延迟（如调度器决策、硬件响应时间）。

解决：预留算力可覆盖延迟期间的负载增长，防止任务堆积。

示例：  

若调频需 5ms 生效，而任务在 5ms 内新增 10% 负载，20% 余量可吸收这部分延迟影响。

兼容非线性负载特性

问题：某些任务（如内存密集型）的 util 可能低估实际需求（因 CPU 等待内存访问时利用率下降）。

解决：预留额外算力补偿潜在低估。

场景：  

若内存延迟导致 util 仅显示 70%，实际需 90% 算力，20% 余量可避免性能损失。

能效与性能的平衡

权衡：  

不预留余量：频率长期满载，功耗高，且无法应对突发负载。  

预留过多余量：频率过高，浪费能源。  

20% 的合理性：  

经验值，在多数场景下能平衡突发负载吸收和能效。  

通过 C=1.25（即 1/0.8）数学上确保 util=80% 时频率饱和。

实际代码中的体现

在 map_util_freq() 的计算中，C=1.25 直接实现了 20% 余量：
// 当 util = 800 (max=1024), max_freq = 2.0 GHz 时：
freq = 1.25  2.0  (800 / 1024) = 1.95 GHz ≈ max_freq

效果：util 达 80% 时，频率已接近 max_freq，剩余 20% 算力供突发使用。

总结：为什么需要算力预留？
原因                具体表现 解决方案

突发负载 瞬时任务导致 util 骤增，可能超出当前频率能力。 预留 20% 算力缓冲。
频率震荡 高频调频增加功耗和延迟。 提前升频，减少波动。
调度/调频延迟 从检测到响应需要时间。 余量覆盖延迟期负载。
非线性负载（如内存瓶颈） util 可能低估实际需求。 额外算力补偿潜在误差。
能效平衡 避免长期满载（高耗电）或过度降频（性能差）。 20% 为经验最优值。

这种设计广泛用于手机、服务器等场景，确保系统在高负载下仍保持响应速度，同时避免不必要的能源浪费。