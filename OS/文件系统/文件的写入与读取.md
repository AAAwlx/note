# 文件的写入与读取

Linux 内核对于文件的读取与写入

```c
struct address_space {
	/* 所属的 inode 或块设备 */
	// 通常address_space会和索引节点(inode)关联，此时host指向此inode
	// 如果address_space不是和索引节点关联，比如和swapper关联，则host域是NULL。
	struct inode		*host;		/* owner: inode, block_device */
	/* 包含全部页面的 radix 树 */
	struct radix_tree_root	page_tree;	/* radix tree of all pages */
	/* 保护基数树的自旋锁 */
	spinlock_t		tree_lock;	/* and lock protecting it */
	/* 可写的 VM_SHARED 映射的计数 */	
	unsigned int		i_mmap_writable;/* count VM_SHARED mappings */
	/* 私有和共享映射的优先级树 */
	// imap是一个优先搜索树，它的搜索范围包含了在address_space范围内所有共享的和私有的映射页面。
	// 优先搜索树是将堆和radix结合形成的快速检索树。可以帮助内核高效找到关联的被缓存文件
	// i_mmap - 根据 vm_area_struct，能够快速的找到关联的缓存文件(即 address_space)，
	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
	/* VM_NONLINEAR 映射列表 */
	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
	/* 保护映射树、计数和列表的自旋锁 */	/* 保护 i_map 的自旋锁 */
	spinlock_t		i_mmap_lock;	/* protect tree, count, list */
	/* 用于处理与截断操作相关的竞态条件 */
	// 截断计数
	unsigned int		truncate_count;	/* Cover race condition with truncate */
	/* 总页数 */
	// address_space页面总数
	unsigned long		nrpages;	/* number of total pages */
	/* 从这里开始回写 */
	// 回写的起始偏移
	pgoff_t			writeback_index;/* writeback starts here */
	/* 方法操作集 */
	const struct address_space_operations *a_ops;	/* methods */
	/* 错误位/内存分配标志 */
	// gfp_mask掩码（内存分配时使用）与错误标识
	unsigned long		flags;		/* error bits/gfp mask */
	/* 后备设备信息，如预读取等 */
	// 预读信息
	struct backing_dev_info *backing_dev_info; /* device readahead, etc */
	// 私有address_space锁
	spinlock_t		private_lock;	/* for use by the address_space */
	// 私有address_space链表
	struct list_head	private_list;	/* ditto */
	// 相关的缓冲
	struct address_space	*assoc_mapping;	/* ditto */
} __attribute__((aligned(sizeof(long))));	/* 确保结构体按长整型大小对齐 */
// 确保结构体按长整型大小对齐，这在大多数架构上已经是默认行为，但在一些架构如CRIS上需要显式声明。
	/*
	 * On most architectures that alignment is already the case; but
	 * must be enforced here for CRIS, to let the least signficant bit
	 * of struct page's "mapping" pointer be used for PAGE_MAPPING_ANON.
	 */
```

```c
struct address_space_operations {
	// 写入页面到磁盘
	int (*writepage)(struct page *page, struct writeback_control *wbc);
	// 从磁盘读取页面到内存
	int (*readpage)(struct file *, struct page *);
	// 同步页面（确保页面完全写入磁盘）
	void (*sync_page)(struct page *);

	/* Write back some dirty pages from this mapping. */
	/* 从这个映射写回一些脏页面 */
	int (*writepages)(struct address_space *, struct writeback_control *);

	/* Set a page dirty.  Return true if this dirtied it */
	/* 设置页面为脏。如果此操作让页面变脏则返回true */
	int (*set_page_dirty)(struct page *page);

	// 批量读取多个页面
	int (*readpages)(struct file *filp, struct address_space *mapping,
			struct list_head *pages, unsigned nr_pages);

	// 开始写操作前的处理
	int (*write_begin)(struct file *, struct address_space *mapping,
				loff_t pos, unsigned len, unsigned flags,
				struct page **pagep, void **fsdata);
	// 完成写操作之后的处理
	int (*write_end)(struct file *, struct address_space *mapping,
				loff_t pos, unsigned len, unsigned copied,
				struct page *page, void *fsdata);

	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
	/* 不幸地，这个替代品是FIBMAP所需要的。请勿使用它 */
	sector_t (*bmap)(struct address_space *, sector_t);
	// 使页面无效
	void (*invalidatepage) (struct page *, unsigned long);
	// 释放一个页面
	int (*releasepage) (struct page *, gfp_t);
	// 执行直接I/O操作
	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
			loff_t offset, unsigned long nr_segs);
	// 获取执行内存的地址
	int (*get_xip_mem)(struct address_space *, pgoff_t, int,
						void **, unsigned long *);
	/* migrate the contents of a page to the specified target */
	/* 迁移一个页面的内容到指定的目标 */
	int (*migratepage) (struct address_space *,
			struct page *, struct page *);
	// 清洗页面，通常用于清除页面的缓存状态
	int (*launder_page) (struct page *);
	// 检查页面的部分区域是否是最新的
	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
					unsigned long);
	// 错误移除页面处理
	int (*error_remove_page)(struct address_space *, struct page *);
};

```

```c
syswrite -> op.write -> do_sync_write -> op.aio ->ext4_file_write -> generic_file_aio_write -> generic_file_buffered_write -> generic_perform_write
```

最终在 `generic_perform_write` 当中将文件写入 pagecache 中。

## pagecache 的回写

Page cache 回写的时机主要由内核中的写回机制（writeback mechanism）控制，用于将脏页（dirty pages）从内存中的 page cache 写回到磁盘，以确保数据持久化。这些回写操作可以基于多种触发条件，下面是一些常见的时机：

1.内存压力（Memory Pressure）

当系统的可用内存不足时，内核会通过 kswapd 或直接内存回收路径启动回写操作，将 page cache 中的脏页写回磁盘，以释放内存空间。

触发条件：可用内存不足，系统需要回收内存以应对内存需求。

执行者：kswapd 线程或直接回收路径中的进程。

2.定期的写回（Periodic Writeback）

Linux 内核有一个后台线程 flush 或 pdflush（旧内核）负责定期扫描 page cache 中的脏页并将它们写回磁盘。这个定期写回过程是为了防止脏页长期堆积在内存中。

触发条件：后台线程根据系统配置的时间间隔，定期扫描并回写脏页。典型的配置值为 30 秒。

执行者：flush 线程。
3.脏页超过阈值（Dirty Page Thresholds）

当系统中的脏页数量超过了设定的阈值时，内核会主动触发写回操作。这些阈值可以通过 /proc/sys/vm/ 下的参数进行调整，例如 dirty_ratio 和 dirty_background_ratio。

dirty_ratio：内存中脏页占总内存的比例，当达到这个比例时，会强制所有进程进行同步回写。

dirty_background_ratio：当脏页占用的内存比例超过这个值时，后台写回线程会启动写回操作。

触发条件：脏页数量超过了设定的阈值。

执行者：flush 线程或触发写回操作的用户进程。

4.显式同步调用（Explicit Sync Calls）

当用户进程调用 sync(), fsync(), 或 msync() 系统调用时，会触发脏页的同步回写。这些操作是用户显式要求数据持久化到磁盘。

触发条件：用户进程调用 sync, fsync, 或 msync 系统调用。
执行者：用户进程。

5.文件关闭（File Close）

当进程关闭文件描述符时，特别是使用 O_SYNC 或 O_DIRECT 打开的文件，在文件关闭时，内核会确保相关的脏页被同步写回到磁盘。

触发条件：进程关闭文件。

执行者：用户进程。

6.设备卸载（Device Unmount）

在卸载文件系统或设备时，内核会触发写回操作，以确保所有脏页在设备卸载前被同步到存储介质中。

触发条件：设备或文件系统的卸载。
执行者：内核的文件系统管理代码。
7.进程内存映射的同步（Memory Mapped File Sync）

使用 mmap() 映射到用户空间的文件，当映射的内存区域被修改时，脏页可能会在适当的时机通过 msync() 或 munmap() 被写回磁盘。

触发条件：调用 msync() 或 munmap()。

执行者：用户进程

### sync

sync 系统调用的功能是将所有系统中的已修改的文件数据同步到磁盘上。它会确保文件系统的元数据和文件数据（例如文件内容、目录、索引节点等）被写回到持久存储设备（如硬盘）。

对于 sync 的处理分为两部分，其中一部分为对于已经写入到pagecache中的内容，另一部分则为文件系统原生的数据如 super_block 等的回写。

![Alt text](sync%E5%9B%9E%E5%86%99%E6%B5%81%E7%A8%8B.png)

在上图中 `wakeup_flusher_threads` 函数这一路进行对于页的回写。

在函数 `bdi_writeback_all` 遍历后备设备列表，并为后备设备列表中有脏数据的设备安排回写任务。

最终会调用后备设备中注册的回写线程进行回写。

![Alt text](%E5%90%8E%E5%A4%87%E8%AE%BE%E5%A4%87.png)

对于没有注册的设备，则使用通用的回写策略 `default_backing_dev_info.wb` 中注册的回写线程。

而对于 wb->task 则在函数 `bdi_register` 中先被统一注册为 `bdi_forker_task`

```c
    if (bdi_cap_flush_forker(bdi)) {
		struct bdi_writeback *wb = &bdi->wb;

		// 启动 bdi_forker_task 线程
		wb->task = kthread_run(bdi_forker_task, wb, "bdi-%s",
						dev_name(dev));
		if (IS_ERR(wb->task)) {	// 如果线程启动失败
			wb->task = NULL;
			ret = -ENOMEM;	// 内存错误

			bdi_remove_from_list(bdi);	// 移除 bdi
			goto exit;
		}
	}
```

而在函数 `bdi_forker_task` 中则会再次创建线程执行 `bdi_start_fn` 函数。

回写线程中的执行流

```c
bdi_forker_task() -> bdi_start_fn() -> bdi_writeback_task() -> wb_do_writeback() -> wb_writeback() - writeback_inodes_wb() -> writeback_sb_inodes() -> writeback_single_inode() -> mapping->a_ops->writepages() -> mpage_writepages() -> write_cache_pages()
```

回写任务的参数会通过 fs/fs-writeback.c 的 writeback_sb_inodes 函数传递给 struct writeback_control wbc。

后续在 mm/page-writeback.c 中 write_cache_pages 就会根据 wbc 的 tagged_writepages 字段进行判断，配置不同的 tag，以及是否需要快速遍历脏页并标记。

最终在函数 write_cache_pages() 完成对文件页面的回写。

文件的回写流程:

```c
file_fsync write_inode_now writeback_single_inode do_writepages mapping->a_ops->writepages
```