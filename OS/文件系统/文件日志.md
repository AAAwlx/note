# 文件系统日志

## 文件系统的一致性

在任意两次写入操作期间，文件系统都可能会发生崩溃或者掉电的情况。如果其中一个写请求到达磁盘，但还没写入磁盘，在此时发生了崩溃，就会造成文件系统的不一致问题。

文件系统崩溃一致性(Crash Consistency)是指在文件系统发生崩溃、断电或其它不可预见的故障后，文件系统能够保证数据的一致性和完整性，并能够恢复到一个合法且可操作的状态，确保系统重新启动或恢复之后，数据不会出现损坏、丢失或不一致的情况。

古老的解决方案是通过文件系统检查程序（file system checker）,即fsck。该方案的思想是并不妨碍或者阻止磁盘不一致状态的产生，而是在崩溃后重启时检查并修复不一致状态。需要手动使用 fsck 命令，进行检查，在使用该命令之后，会对超级块中，inode等结构进行检查，检查有没有重复的块。这样每次都需要对磁盘进行遍历的方式就十分低效。在此基础上又产生了文件系统

[fsck原理](https://blog.csdn.net/weixin_29196613/article/details/116907036)

文件系统日志的诞生就是为了防止这一现象的产生。

### 日志工作原理

#### 日志提交

在ext4文件系统中，由 inode 号为 8 的文件对日志数据进行保存。在执行对文件系统写入或修改元数据操作时，会开启一组事务并将事务提交到磁盘的日志数据区中。

![Alt text](image-1.png)

* 事务开始:文件系统开始一组更新操作，并开启一个新的事务

* 收集日志:收集所有即将修改的数据(以及在 Journal 模式下的数据)

* 提交日志:更新日志头，标记该事务已经提交(commit)

* 应用事务:将日志中的修改应用到文件系统，将数据和元数据写入最终位置

* 清理日志:事务完成后，日志系统清理已提交的日志记录

#### 日志恢复

在文件系统被挂载时，会对文件系统的日志文件进行扫描，与日志缓冲区中的事务进行对比查看是否有未完成的操作，如果有未完成的操作，则看磁盘的日志数据区中是否有提交。

* 如果有则根据日志对文件系统进行重做与恢复
* 如果没有提交日志则直接放弃本次修改操作

## 日志文件系统中的结构体

```c
/**
 * struct journal_s - 日志管理的数据结构
 *
 * 这个结构体定义了 journaling 文件系统的核心数据结构，它用于管理文件系统的日志操作。
 * 在这里，各种字段负责不同的日志功能，包括事务管理、同步、检查点、设备信息等。
 * 这些字段使用锁（如自旋锁和互斥锁）来保护并发访问。
 */

struct journal_s
{
	/* 日志的一般状态标志位 [受 j_state_lock 保护] */
	unsigned long		j_flags;

	/* 是否有来自先前终止的未清除错误 [受 j_state_lock 保护] */
	int			j_errno;

	/* 日志超级块的缓冲区 */
	struct buffer_head	*j_sb_buffer;
	/* 日志的超级块指针 */
	journal_superblock_t	*j_superblock;

	/* 超级块格式的版本 */
	int			j_format_version;

	/* 用于保护日志的各种标量 [自旋锁] */
	spinlock_t		j_state_lock;

	/* 等待创建屏障锁的进程数量 [受 j_state_lock 保护] */
	int			j_barrier_count;

	/* 屏障锁 */
	struct mutex		j_barrier;

	/* 当前运行的事务 [受 j_state_lock 和调用者持有的 open handle 保护] */
	transaction_t		*j_running_transaction;

	/* 正在推送到磁盘的事务 [受 j_state_lock 和调用者持有的 open handle 保护] */
	transaction_t		*j_committing_transaction;

	/* 所有等待检查点的事务的循环链表 [受 j_list_lock 保护] */
	transaction_t		*j_checkpoint_transactions;

	/* 等待队列，等待事务锁定开始提交，或屏障锁释放 */
	wait_queue_head_t	j_wait_transaction_locked;

	/* 等待队列，等待检查点完成 */
	wait_queue_head_t	j_wait_logspace;

	/* 等待队列，等待提交完成 */
	wait_queue_head_t	j_wait_done_commit;

	/* 等待队列，触发检查点 */
	wait_queue_head_t	j_wait_checkpoint;

	/* 等待队列，触发提交 */
	wait_queue_head_t	j_wait_commit;

	/* 等待队列，等待更新完成 */
	wait_queue_head_t	j_wait_updates;

	/* 保护并发检查点的信号量 */
	struct mutex		j_checkpoint_mutex;

	/* 日志头：标识日志中第一个未使用的块 [受 j_state_lock 保护] */
	unsigned int		j_head;

	/* 日志尾：标识日志中仍在使用的最旧块 [受 j_state_lock 保护] */
	unsigned int		j_tail;

	/* 日志空闲空间：日志中有多少空闲块 [受 j_state_lock 保护] */
	unsigned int		j_free;

	/* 日志开始和结束块号 [受 j_state_lock 保护] */
	unsigned int		j_first;
	unsigned int		j_last;

	/* 存储日志的位置的设备、块大小和起始块偏移量 */
	struct block_device	*j_dev;
	int			j_blocksize;
	unsigned int		j_blk_offset;

	/* 客户文件系统所在的设备。对于内部日志，它将等于 j_dev。 */
	struct block_device	*j_fs_dev;

	/* 日志区域在磁盘上的最大容量（单位：块） */
	unsigned int		j_maxlen;

	/* 保护缓冲区列表和内部缓冲区状态的自旋锁 */
	spinlock_t		j_list_lock;

	/* 存储日志的可选 inode，如果存在，所有日志块号通过 bmap() 映射到此 inode */
	struct inode		*j_inode;

	/* 日志中最旧事务的序列号 [受 j_state_lock 保护] */
	tid_t			j_tail_sequence;

	/* 下一个事务的序列号 [受 j_state_lock 保护] */
	tid_t			j_transaction_sequence;

	/* 最近提交的事务的序列号 [受 j_state_lock 保护] */
	tid_t			j_commit_sequence;

	/* 最近请求提交的事务的序列号 [受 j_state_lock 保护] */
	tid_t			j_commit_request;

	/* 日志的 UUID：标识由此日志支持的对象（文件系统、LVM 卷等） */
	__u8			j_uuid[16];

	/* 指向当前提交线程的指针 */
	struct task_struct	*j_task;

	/* 允许单个复合提交事务中的最大元数据缓冲区数 */
	int			j_max_transaction_buffers;

	/* 提交事务前的最大事务存续时间 */
	unsigned long		j_commit_interval;

	/* 唤醒提交线程的定时器 */
	struct timer_list	j_commit_timer;

	/* 撤销表：维护当前事务中撤销的块列表 [受 j_revoke_lock 保护] */
	spinlock_t		j_revoke_lock;
	struct jbd_revoke_table_s *j_revoke;
	struct jbd_revoke_table_s *j_revoke_table[2];

	/* journal_commit_transaction 中的缓冲头数组 */
	struct buffer_head	**j_wbuf;
	int			j_wbufsize;

	/* 最近执行同步操作的进程的 pid */
	pid_t			j_last_sync_writer;

	/* 提交事务到磁盘的平均时间（纳秒） [受 j_state_lock 保护] */
	u64			j_average_commit_time;

	/* 文件系统私有信息的指针。ext3 将它的超级块指针放在这里。 */
	void *j_private;
};

```

## 文件日志系统的初始化

文件日志系统是作为模块被加载到内核中的，

```c
//module_init(journal_init);
static int __init journal_init(void) // 定义一个初始化函数，使用 __init 修饰符表示这是一个初始化代码
{
	int ret; // 声明一个整型变量用于存储返回值

	BUILD_BUG_ON(sizeof(struct journal_superblock_s) != 1024); // 编译时检查结构体大小是否为 1024 字节

	ret = journal_init_caches(); // 调用函数初始化日志缓存，并将返回值存储在 ret 中
	if (ret == 0) { // 如果初始化成功（返回值为 0）
		jbd2_create_debugfs_entry(); // 创建调试文件系统条目
		jbd2_create_jbd_stats_proc_entry(); // 创建用于统计的 proc 条目
	} else { // 如果初始化失败
		jbd2_journal_destroy_caches(); // 销毁已经创建的缓存
	}
	return ret; // 返回初始化结果
}
```

## ext4日志的初始化

在 ext4 文件系统被挂载是，探测函数会调用 ext4_fill_super 函数读取ext4的超级块并作出处理。在该函数中会对super中的内容进行检测是否开启日志模式，如果开启了日志模式则将对日志系统进行加载。

```c
	if (!test_opt(sb, NOLOAD) &&
	    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {
		if (ext4_load_journal(sb, es, journal_devnum))
			goto failed_mount3;
	}
```

在ext4_load_journal中会对日志对象进行初始化

```c
if (journal_inum) {
		// 使用 inode 号获取日志
		if (!(journal = ext4_get_journal(sb, journal_inum)))
			return -EINVAL; // 如果获取失败，返回无效参数错误
	} else {
		// 使用设备号获取日志
		if (!(journal = ext4_get_dev_journal(sb, journal_dev)))
			return -EINVAL; // 如果获取失败，返回无效参数错误
	}
```

在 Ext4 文件系统中，**inode 日志**和**设备日志**不能共存的原因在于它们表示了两种完全不同的日志管理模式，且同时存在会导致日志管理的冲突和不一致。

1. **inode 日志**
   - **inode 日志**（journal in inode）指的是日志数据存储在文件系统的某个特殊 inode 中。此时，日志是文件系统的一部分，日志操作与文件系统的其他文件类似，使用文件系统本身管理日志的存储和操作。

   - **使用场景**：这种方式主要用于单一设备的文件系统（即文件系统和日志都存储在同一个设备上）。在这种情况下，日志记录的所有元数据更容易与文件系统的状态保持一致。

2. **设备日志**

   - **设备日志**（external journal device）指的是日志数据存储在一个独立的设备上（通常是不同于文件系统数据存储的设备）。该日志设备专门用于存储文件系统的日志操作。

   - **使用场景**：这种方式主要用于提升性能或分离存储负载的场景。将日志操作与文件系统数据分开，可以减少文件系统设备上的写入压力，尤其在高并发场景下。

```c
/*
 * 获取并初始化文件系统的日志对象。
 *
 * @param sb: 超级块指针，表示当前文件系统的超级块。
 * @param journal_inum: 日志 inode 号，表示存储日志的 inode 编号。
 * 
 * 返回值：
 * - 返回指向日志结构体的指针，如果获取日志失败，则返回 NULL。
 */
static journal_t *ext4_get_journal(struct super_block *sb, unsigned int journal_inum)
{
    struct inode *journal_inode; // 指向日志 inode 的指针
    journal_t *journal;          // 指向日志结构体的指针

    // 保证文件系统启用了具有日志功能的兼容特性
    BUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));

    /*
     * 首先检查磁盘上是否存在有效的日志 inode。
     * 如果获取到的是无效 inode（如未使用），在 iput() 过程中
     * 将尝试删除该 inode，可能导致系统异常。
     */
    journal_inode = ext4_iget(sb, journal_inum); // 根据 inode 号获取 inode
    if (IS_ERR(journal_inode)) { // 检查获取 inode 是否失败
        ext4_msg(sb, KERN_ERR, "no journal found"); // 打印错误信息，未找到日志 inode
        return NULL; // 返回 NULL 表示获取日志失败
    }

    // 检查日志 inode 的链接计数是否为 0（已删除的 inode）
    if (!journal_inode->i_nlink) {
        make_bad_inode(journal_inode); // 标记该 inode 为坏 inode
        iput(journal_inode); // 释放该 inode
        ext4_msg(sb, KERN_ERR, "journal inode is deleted"); // 打印错误信息，日志 inode 已被删除
        return NULL; // 返回 NULL 表示获取日志失败
    }

    // 打印调试信息，输出日志 inode 地址及其大小
    jbd_debug(2, "Journal inode found at %p: %lld bytes\n", journal_inode, journal_inode->i_size);

    // 检查日志 inode 的类型是否为常规文件（日志文件必须是常规文件）
    if (!S_ISREG(journal_inode->i_mode)) {
        ext4_msg(sb, KERN_ERR, "invalid journal inode"); // 打印错误信息，日志 inode 类型无效
        iput(journal_inode); // 释放该 inode
        return NULL; // 返回 NULL 表示获取日志失败
    }

    // 初始化 inode 作为日志并获取日志对象
    journal = jbd2_journal_init_inode(journal_inode);
    if (!journal) { // 如果日志初始化失败
        ext4_msg(sb, KERN_ERR, "Could not load journal inode"); // 打印错误信息，无法加载日志 inode
        iput(journal_inode); // 释放 inode
        return NULL; // 返回 NULL 表示获取日志失败
    }

    // 设置日志对象的私有数据为超级块
    journal->j_private = sb;

    // 初始化日志参数
    ext4_init_journal_params(sb, journal);

    return journal; // 返回初始化后的日志对象
}
```

基于 inode 初始化日志

```c
/**
 * jbd2_journal_init_inode - 基于 inode 初始化日志
 * @inode: 文件系统的 inode 对象
 *
 * 该函数通过 inode 对象初始化一个 journal_t 类型的日志对象。
 * 它会设置日志的各种属性，包括设备名、块大小等。
 *
 * 返回值: 如果成功，返回 journal_t* 指针；如果失败，返回 NULL。
 */

journal_t * jbd2_journal_init_inode (struct inode *inode)
{
	struct buffer_head *bh;
	journal_t *journal = journal_init_common(); // 初始化一个通用的 journal 结构
	char *p;
	int err;
	int n;
	unsigned long long blocknr;

	// 如果 journal 初始化失败，直接返回 NULL
	if (!journal)
		return NULL;

	// 设置日志设备和文件系统设备为 inode 所在的块设备
	journal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;
	// 将 inode 与日志关联
	journal->j_inode = inode;
	// 获取块设备名称
	bdevname(journal->j_dev, journal->j_devname);
	// 将设备名中的 '/' 替换为 '!'，防止路径字符的冲突
	p = journal->j_devname;
	while ((p = strchr(p, '/')))
		*p = '!';
	// 添加 inode 号到设备名的结尾
	p = journal->j_devname + strlen(journal->j_devname);
	sprintf(p, "-%lu", journal->j_inode->i_ino);

	// 输出调试信息，日志的 inode 信息及其大小、块大小等
	jbd_debug(1,
		  "journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\n",
		  journal, inode->i_sb->s_id, inode->i_ino,
		  (long long) inode->i_size,
		  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);

	// 计算日志的最大长度（单位：块数）
	journal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;
	// 设置日志的块大小
	journal->j_blocksize = inode->i_sb->s_blocksize;
	// 初始化日志的统计信息
	jbd2_stats_proc_init(journal);

	// 计算日志描述符能够存储的块数
	n = journal->j_blocksize / sizeof(journal_block_tag_t);
	journal->j_wbufsize = n;
	// 为写缓冲区分配内存
	journal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);
	if (!journal->j_wbuf) {
		printk(KERN_ERR "%s: Cant allocate bhs for commit thread\n",
			__func__);
		goto out_err;
	}

	// 获取日志的超级块（第 0 块）的物理块号
	err = jbd2_journal_bmap(journal, 0, &blocknr);
	// 如果映射失败，记录错误并退出
	if (err) {
		printk(KERN_ERR "%s: Cannnot locate journal superblock\n",
		       __func__);
		goto out_err;
	}

	// 获取日志超级块所在的缓冲区
	bh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);
	if (!bh) {
		printk(KERN_ERR
		       "%s: Cannot get buffer for journal superblock\n",
		       __func__);
		goto out_err;
	}
	// 设置日志的超级块缓冲区和超级块指针
	journal->j_sb_buffer = bh;
	journal->j_superblock = (journal_superblock_t *)bh->b_data;

	// 返回初始化好的 journal 对象
	return journal;

out_err:
	// 错误处理：释放已分配的资源并返回 NULL
	kfree(journal->j_wbuf);
	jbd2_stats_proc_exit(journal);
	kfree(journal);
	return NULL;
}

```

`jbd2_stats_proc_init` 函数会在 proc 目录