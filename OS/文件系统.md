# 文件系统

## 一切皆文件的构想

在 Linux 的设计中秉持着“一切皆文件的构想”。无论是普通的文件还是设备进程等，都可以被视作文件。通过文件系统提供的系统调用对其进行操作。

文件系统依据存储介质的不同可以分为3类。

1. 依托于磁盘的磁盘文件系统
2. 依托于网卡的网络文件系统
3. 依托于内存的虚拟文件系统

![linux文件系统结构](/home/ylx/下载/linux文件系统结构.png)



虽然具体的文件系统各有不同，但在用户态下无需考虑文件系统的具体操作。无论是什么文件系统都可以通过例如read()，write()这样的系统调用对文件系统进行操作。

那么 Linux 内核如何将各类文件系统的操作向用户屏蔽，只向用户提供统一的系统调用？

由此引入虚拟文件系统 VFS ，VFS 中采取面向对象的设计思想。提供一个基类，再由具体的文件系统实现。从而达到向用户层屏蔽细节的目的。

## 文件系统中的结构体

文件系统中面向对象的思想由诸多类型的结构体，联合体相互关联实现。

### superblock

超级块中存储着文件系统的元信息，包括块大小、文件系统的大小、最大文件大小、根目录的位置等。以供操作系统识别文件系统类型，并对其内部的数据进行处理。

```c
struct super_block {
	struct list_head s_list;		/* 用于将超级块添加到超级块链表中，必须放在结构体的第一个位置 */
	dev_t s_dev;				/* 设备号，用于标识文件系统所关联的设备 */
	unsigned char s_dirt;			/* 标志文件系统是否有脏数据（需要写回磁盘） */
	unsigned char s_blocksize_bits;		/* 块大小的位数，用于计算块大小 */
	unsigned long s_blocksize;		/* 文件系统的块大小（以字节为单位） */
	loff_t s_maxbytes;			/* 文件系统中文件的最大大小 */
	struct file_system_type *s_type;	/* 文件系统类型 */
	const struct super_operations *s_op;	/* 超级块操作函数指针，定义文件系统特定的操作 */
	const struct dquot_operations *dq_op;	/* 磁盘配额操作函数指针 */
	const struct quotactl_ops *s_qcop;	/* 磁盘配额控制操作函数指针 */
	const struct export_operations *s_export_op; /* 导出操作函数指针（用于网络文件系统） */
	unsigned long s_flags;			/* 文件系统标志，用于记录文件系统的状态 */
	unsigned long s_magic;			/* 魔数，用于标识文件系统类型 */
	struct dentry *s_root;			/* 文件系统的根目录入口 */
	struct rw_semaphore s_umount;		/* 读写信号量，用于卸载文件系统的同步控制 */
	struct mutex s_lock;			/* 互斥锁，用于保护超级块的访问 */
	int s_count;				/* 引用计数，表示文件系统被引用的次数 */
	int s_need_sync;			/* 标志是否需要同步 */
	atomic_t s_active;			/* 活动计数，用于引用计数 */
#ifdef CONFIG_SECURITY
	void *s_security;			/* 安全模块的私有数据（如果启用了安全模块） */
#endif
	struct xattr_handler **s_xattr;		/* 扩展属性处理程序数组 */
	struct list_head s_inodes;		/* 文件系统中的所有 inode 的链表 */
	struct hlist_head s_anon;		/* 匿名 dentry 链表（用于 NFS 导出） */
	struct list_head s_files;		/* 文件系统中的所有文件的链表 */
	struct list_head s_dentry_lru;		/* 未使用的 dentry 的 LRU 链表 */
	int s_nr_dentry_unused;			/* 未使用的 dentry 数量 */
	struct block_device *s_bdev;		/* 关联的块设备 */
	struct backing_dev_info *s_bdi;		/* 后备设备信息 */
	struct mtd_info *s_mtd;			/* 关联的 MTD（内存技术设备）信息 */
	struct list_head s_instances;		/* 超级块实例链表 */
	struct quota_info s_dquot;		/* 磁盘配额特定信息 */
	int s_frozen;				/* 文件系统是否被冻结 */
	wait_queue_head_t s_wait_unfrozen;	/* 用于等待文件系统解冻的等待队列 */
	char s_id[32];				/* 文件系统的标识符名称 */
	void *s_fs_info;			/* 文件系统的私有信息 */
	fmode_t s_mode;				/* 文件系统的模式 */
	u32 s_time_gran;			/* c/m/atime 的时间粒度（以纳秒为单位） */
	struct mutex s_vfs_rename_mutex;	/* 用于 VFS 重命名的互斥锁（仅供 VFS 使用） */
	char *s_subtype;			/* 文件系统的子类型 */
	char *s_options;			/* 保存挂载选项 */
};
```

### inode

```c
struct inode {
    struct hlist_node i_hash;                   // 用于将 inode 插入到哈希链表中的节点
    struct list_head i_list;                    // 支持设备 IO 的链表
    struct list_head i_sb_list;                 // 超级块 (super block) 的链表
    struct list_head i_dentry;                  // 目录项 (dentry) 链表
    unsigned long i_ino;                        // inode 号码
    atomic_t i_count;                           // 引用计数
    unsigned int i_nlink;                       // 硬链接计数
    uid_t i_uid;                                // 所有者用户 ID
    gid_t i_gid;                                // 所有者组 ID
    dev_t i_rdev;                               // 设备 ID（对于设备文件）
    unsigned int i_blkbits;                     // 块大小的比特数
    u64 i_version;                              // inode 版本号
    loff_t i_size;                              // 文件大小（以字节为单位）
#ifdef __NEED_I_SIZE_ORDERED
    seqcount_t i_size_seqcount;                 // 顺序计数，用于确保 i_size 的一致性
#endif
    struct timespec i_atime;                    // 最后访问时间
    struct timespec i_mtime;                    // 最后修改时间
    struct timespec i_ctime;                    // 最后状态改变时间
    blkcnt_t i_blocks;                          // 占用的块数
    unsigned short i_bytes;                     // 占用的字节数
    umode_t i_mode;                             // 文件类型和权限
    spinlock_t i_lock;                          // 自旋锁，用于保护 i_blocks、i_bytes 和可能的 i_size
    struct mutex i_mutex;                       // 互斥锁
    struct rw_semaphore i_alloc_sem;            // 读写信号量
    const struct inode_operations *i_op;        // inode 操作函数指针
    const struct file_operations *i_fop;        // 文件操作函数指针（之前是 i_op->default_file_ops）
    struct super_block *i_sb;                   // 所属的超级块
    struct file_lock *i_flock;                  // 文件锁
    struct address_space *i_mapping;            // 关联的地址空间（主地址空间）
    struct address_space i_data;                // 数据地址空间
#ifdef CONFIG_QUOTA
    struct dquot *i_dquot[MAXQUOTAS];           // 与 inode 关联的磁盘配额信息
#endif
    struct list_head i_devices;                 // 设备链表
    union {
        struct pipe_inode_info *i_pipe;         // 管道信息
        struct block_device *i_bdev;            // 块设备信息
        struct cdev *i_cdev;                    // 字符设备信息
    };
    __u32 i_generation;                         // inode 生成号
#ifdef CONFIG_FSNOTIFY
    __u32 i_fsnotify_mask;                      // inode 关注的所有事件掩码
    struct hlist_head i_fsnotify_mark_entries;  // fsnotify 标记条目链表
#endif
#ifdef CONFIG_INOTIFY
    struct list_head inotify_watches;           // 这个 inode 上的 inotify 监视列表
    struct mutex inotify_mutex;                 // 保护 inotify 监视列表的互斥锁
#endif
    unsigned long i_state;                      // inode 状态
    unsigned long dirtied_when;                 // 第一次被弄脏的时间（以 jiffies 为单位）
    unsigned int i_flags;                       // inode 标志
    atomic_t i_writecount;                      // 写计数
#ifdef CONFIG_SECURITY
    void *i_security;                           // 安全模块使用的指针
#endif
#ifdef CONFIG_FS_POSIX_ACL
    struct posix_acl *i_acl;                    // POSIX ACL
    struct posix_acl *i_default_acl;            // 默认的 POSIX ACL
#endif
    void *i_private;                            // 文件系统或设备私有指针
};
```



### dir与dirent



### file



### 操作函数

在上文中提到的结构体中有指针 s_op ，i_op等，他们起到了类似于面向对象语言中虚函数的作用。

此类结构体中定义了对该结构体所有操作的函数指针，在文件系统初始化时由各个文件系统自行注册该文件系统中所需要用到的操作。

#### super_operations

该结构体在 include/fs.h 中给出。

```c
struct super_operations {
	/* 分配一个新的 inode */
	struct inode *(*alloc_inode)(struct super_block *sb);
	/* 销毁一个 inode */
	void (*destroy_inode)(struct inode *);

	/* 标记 inode 为脏 */
	void (*dirty_inode) (struct inode *);
	/* 将 inode 写入磁盘 */
	int (*write_inode) (struct inode *, struct writeback_control *wbc);
	/* 删除 inode 的引用 */
	void (*drop_inode) (struct inode *);
	/* 删除 inode */
	void (*delete_inode) (struct inode *);
	/* 卸载文件系统时调用，释放超级块资源 */
	void (*put_super) (struct super_block *);
	/* 写入超级块信息 */
	void (*write_super) (struct super_block *);
	/* 同步文件系统 */
	int (*sync_fs)(struct super_block *sb, int wait);
	/* 冻结文件系统 */
	int (*freeze_fs) (struct super_block *);
	/* 解冻文件系统 */
	int (*unfreeze_fs) (struct super_block *);
	/* 获取文件系统状态 */
	int (*statfs) (struct dentry *, struct kstatfs *);
	/* 重新挂载文件系统 */
	int (*remount_fs) (struct super_block *, int *, char *);
	/* 清除 inode */
	void (*clear_inode) (struct inode *);
	/* 卸载开始时调用 */
	void (*umount_begin) (struct super_block *);

	/* 显示挂载选项 */
	int (*show_options)(struct seq_file *, struct vfsmount *);
	/* 显示文件系统统计信息 */
	int (*show_stats)(struct seq_file *, struct vfsmount *);
#ifdef CONFIG_QUOTA
	/* 读取配额 */
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	/* 写入配额 */
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
#endif
	/* 尝试释放页面 */
	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
};

```

ext2的操作函数在 fs/ext2/super.c 中注册。

```c
static const struct super_operations ext2_sops = {
	.alloc_inode	= ext2_alloc_inode,
	.destroy_inode	= ext2_destroy_inode,
	.write_inode	= ext2_write_inode,
	.delete_inode	= ext2_delete_inode,
	.put_super	= ext2_put_super,
	.write_super	= ext2_write_super,
	.sync_fs	= ext2_sync_fs,
	.statfs		= ext2_statfs,
	.remount_fs	= ext2_remount,
	.clear_inode	= ext2_clear_inode,
	.show_options	= ext2_show_options,
#ifdef CONFIG_QUOTA
	.quota_read	= ext2_quota_read,
	.quota_write	= ext2_quota_write,
#endif
};
```

那如果有些文件系统并没有将里面的函数指针全部注册又该怎么办？

在处理系统调用时会判断函数指针是否为NULL，如果为 NULL 则使用 VFS 中默认的处理函数。

## 文件系统初始化过程

### 构建根文件系统



![文件系统初始化](/home/ylx/下载/文件系统初始化.png)

图中由两条调用链组成。其中rest_init这一条的作用是解析initrd文件，而mnt_init这一条则是设置一个 / 目录为文件系统提供根挂载点。

#### 初始化根目录

初始化根目录的主要目的是为 VFS 创建一个供文件系统挂载的根目录。

为了保证所有设备都被 sysfs 所记录，因此为了保证信息记录完全，因此 sysfs 要先于 rootfs 被挂载。

在 init_roots 中会注册 rootfs 与 其操作函数。

初始化后的根目录会被记录在task_struct中。

#### 解析initrd文件

1. 什么是initrd文件？

    initrd是一个临时文件系统，由bootload负责加载到内存中，里面包含了基本的可执行程序和驱动程序。在linux初始化的初级阶段，它提供了一个基本的运行环境。当成功加载磁盘文件系统后，系统将切换到磁盘文件系统并卸载initrd。

    如果是嵌入式设备，那么最终的文件系统就是initrd。

   在该文件系统内提供了一些基础的目录与一个可执行程序init，由init进程负责后面内核的初始化工作。

   initrd常用的文件格式为cpio文件格式。在编译内核时，该文件会作为内核的一个段被编译进内核中。并在内核初始化时被解析。

2. 如何解析initrd文件

   Linux内核中由 populate_rootfs() 解析 initrd 文件，其被注册在 initcall 段中。

3. 将解析出的目录记录在 rootfs 中

   







![目录树 (1)](/home/ylx/下载/目录树 (1).png)

### 从磁盘中加载文件系统

将