# 伙伴系统

伙伴系统是一个结合了2的方幂个分配器和空闲缓冲区合并计技术的内存分配方案, 其基本思想很简单. 内存被分成含有很多页面的大块, 每一块都是2个页面大小的方幂. 如果找不到想要的块, 一个大块会被分成两部分, 这两部分彼此就成为伙伴. 其中一半被用来分配, 而另一半则空闲. 这些块在以后分配的过程中会继续被二分直至产生一个所需大小的块. 当一个块被最终释放时, 其伙伴将被检测出来, 如果伙伴也空闲则合并两者.

## 伙伴系统中需要的结构体

在 zone 中将记录了一个`free_area`结构的数组。

```c
struct zone
{
     /* free areas of different sizes */
    struct free_area        free_area[MAX_ORDER];
};
```

数组中第0个元素的阶为0, 它的free_list链表域指向具有包含区为单页(2^0 = 1)的内存页面链表

数组中第1个元素的free_list域管理的内存区为两页(2^1 = 2)

第3个管理的内存区为4页, 依次类推.

直到 2^MAXORDER-1个页面大小的块

```c
struct free_area {
    struct list_head        free_list[MIGRATE_TYPES];//链表头，将不同的页面类型放到对应的链表中
    unsigned long           nr_free;
};
```

在伙伴系统中为了满足页面的分裂合并逻辑，同时也为kswap机制，将页面分为三种类型（2.6）

* 不可移动页 MIGRATE_UNMOVABLE
  
  在内存中有固定位置, 不能移动到其他地方

  核心内核分配的大多数内存属于该类别

* 可移动页 MIGRATE_MOVABLE
  
  可以随意地移动. 属于用户空间应用程序的页属于该类别
  
  它们是通过页表映射的如果它们复制到新位置，页表项可以相应地更新，应用程序不会注意到任何事

* 可回收页 MIGRATE_RECLAIMABLE
  
  不能直接移动, 但可以删除, 其内容可以从某些源重新生成

  例如，映射自文件的数据属于该类别。kswapd守护进程会根据可回收页访问的频繁程度，周期性释放此类内存。 页面回收本身就是一个复杂的过程。 内核会在可回收页占据了太多内存时进行回收, 在内存短缺(即分配失败)时也可以发起页面回收。

* 保留内存页 MIGRATE_RESERVE
  
  表示保留类型的页面。这类页面仅在内存极度紧张的情况下才会被分配，主要用于确保系统在特殊情况下仍然能够分配一些页面。
  
* 隔离页面 MIGRATE_ISOLATE
  表示隔离页面。不能从这些页面中进行分配，通常用于内存热插拔或内存离线操作。当内存块需要隔离时，这些页面会被标记为 MIGRATE_ISOLATE，从而避免被内存分配器使用

## 伙伴系统的初始化

在内存的初始化阶段与伙伴系统相关的有两部分

- zone_init_free_lists
  在该函数中主要是针对 zone 结构中 free_are 成员的初始化。
  * INIT_LIST_HEAD(&zone->free_area[order].free_list[t]) 初始化free_list
  * nr_free = 0; 初始化空闲页面的计数。

在上这步中，伙伴系统中并没有空闲页面的存在。

- mem_init
  该函数主要用于释放 bootmem 中的页，并将其迁移至伙伴系统
  
  在该函数中最终会调用到伙伴系统中用来释放页的接口 `__free_pages`

经过 mem_init 后伙伴系统中才会有空闲页面

![Alt text](image.png)

![Alt text](image-1.png)

## 伙伴系统中页面的释放

![Alt text](伙伴系统释放页面.png)

```c
static inline void __free_one_page(struct page *page,
		struct zone *zone, unsigned int order,
		int migratetype)
{
	unsigned long page_idx;

	// 如果页面是复合页面，处理并销毁复合页面
	if (unlikely(PageCompound(page)))
		if (unlikely(destroy_compound_page(page, order)))
			return;

	// 检查迁移类型是否有效
	VM_BUG_ON(migratetype == -1);

	// 获取页面索引 (page frame number, PFN)，并限制在 MAX_ORDER 范围内
	page_idx = page_to_pfn(page) & ((1 << MAX_ORDER) - 1);

	// 确保页面索引对齐到 order 的大小，并检查页面范围是否有效
	VM_BUG_ON(page_idx & ((1 << order) - 1));
	VM_BUG_ON(bad_range(zone, page));

	// 合并相邻的伙伴页面，提升 order
	while (order < MAX_ORDER-1) {
		unsigned long combined_idx;
		struct page *buddy;

		// 查找相应的伙伴页面
		buddy = __page_find_buddy(page, page_idx, order);
		
		// 如果找不到符合条件的伙伴页面，停止合并
		if (!page_is_buddy(page, buddy, order))
			break;

		// 如果找到空闲的伙伴页面，合并它们，提升 order 等级
		list_del(&buddy->lru); // 从空闲链表中删除伙伴页面
		zone->free_area[order].nr_free--; // 更新该 order 下的空闲页面计数
		rmv_page_order(buddy); // 移除伙伴页面的 order 信息
		
		// 计算合并后的页面索引，并更新页面指针
		combined_idx = __find_combined_index(page_idx, order);
		page = page + (combined_idx - page_idx); // 更新为合并后的页面
		page_idx = combined_idx; // 更新合并后的页面索引
		order++; // 提升 order 等级
	}

	// 设置页面的 order 并将其插入到合适的空闲链表中
	set_page_order(page, order);
	list_add(&page->lru, &zone->free_area[order].free_list[migratetype]); // 插入到相应 order 的空闲链表中
	zone->free_area[order].nr_free++; // 更新空闲页面计数
}
```

## 伙伴系统中页面的分配

就伙伴系统的接口而言, NUMA或UMA体系结构是没有差别的, 二者的调用语法都是相同的。

所有函数的一个共同点是 : 只能分配2的整数幂个页。

因此，接口中不像C标准库的malloc函数或bootmem和memblock分配器那样指定了所需内存大小作为参数。相反, 必须指定的是分配阶, 伙伴系统将在内存中分配2^0页。

内核中细粒度的分配只能借助于slab分配器(或者slub、slob分配器), 后者基于伙伴系统。

![Alt text](../image/伙伴系统页分配的api.png)

上述函最终都会调用 `alloc_pages_node` ，最终进入伙伴系统分配页的核心函数。

```c
struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
			struct zonelist *zonelist, nodemask_t *nodemask)
{
	// 获取 GFP 标志对应的高区域索引（即从哪个内存区域分配页面，例如 ZONE_NORMAL, ZONE_HIGHMEM）
	enum zone_type high_zoneidx = gfp_zone(gfp_mask);
	struct zone *preferred_zone;  // 优选区域
	struct page *page;
	int migratetype = allocflags_to_migratetype(gfp_mask);  // 获取分配的迁移类型

	// 掩码校正，确保 GFP 标志只包含允许的位
	gfp_mask &= gfp_allowed_mask;

	// 锁定分配跟踪
	lockdep_trace_alloc(gfp_mask);

	// 如果 GFP 标志要求等待，则可能需要睡眠
	might_sleep_if(gfp_mask & __GFP_WAIT);

	// 根据 GFP 标志模拟分配失败（用于测试目的）
	if (should_fail_alloc_page(gfp_mask, order))
		return NULL;

	/*
	 * 检查满足 gfp_mask 要求的内存区域是否至少包含一个有效的区域。
	 * 如果使用了 GFP_THISNODE 或者当前节点没有内存，则可能出现空的区域列表。
	 */
	if (unlikely(!zonelist->_zonerefs->zone))
		return NULL;

	// 获取优选的区域，并在之后用于统计
	first_zones_zonelist(zonelist, high_zoneidx, nodemask, &preferred_zone);
	if (!preferred_zone)
		return NULL;

	// 第一次尝试分配页面，从空闲列表中获取页面
	page = get_page_from_freelist(gfp_mask|__GFP_HARDWALL, nodemask, order,
			zonelist, high_zoneidx, ALLOC_WMARK_LOW|ALLOC_CPUSET,
			preferred_zone, migratetype);

	// 如果第一次尝试失败，进入慢路径重新尝试分配
	if (unlikely(!page))
		page = __alloc_pages_slowpath(gfp_mask, order,
				zonelist, high_zoneidx, nodemask,
				preferred_zone, migratetype);

	// 记录页面分配的跟踪信息
	trace_mm_page_alloc(page, order, gfp_mask, migratetype);

	// 返回分配的页面
	return page;
}
EXPORT_SYMBOL(__alloc_pages_nodemask);
```

![Alt text](../image/页面的分配.png)

在该函数的流程中，首先调用 first_zones_zonelist 该函数用于遍历 zonelist 并根据 nodemask 找到对应的 preferred_zone 。

在分配时，会优先考虑 preferred_zone 区域中的空闲页。

随后使用 get_page_from_freelist 对空闲页面进行分配。对页面的分配最终会调用 `__rmqueue_smallest` 与 `__rmqueue_fallback` 对不同的情况做出处理。

- __rmqueue_smallest
  
  在函数 __rmqueue_smallest 中只会对migratetype类型的链表进行操作，并且会按照需要的阶数在 zone 中的 free_area 数组中依次向上遍历。如果获取到页面的阶数大于需要的阶数，则会对页面进行分裂。

  比如最初传入的值是8，而成功分配是10，那么就会连续页框进行拆分，这时候就会拆分为256、256、512这三块连续页框，并把512放入order为9的free_list，把一个256放入order为8的free_list，剩余一个256用于分配。

- __rmqueue_fallback
  
  __rmqueue_fallback()函数中，主要根据fallbacks表，尝试将其他migratetype类型的pageblock中的空闲页移动到目标类型的mirgratetype类型的空闲页框块链表中

在上述代码中对于页的分配依赖于gfp_mask，那么是什么是gfp_mask？

## 页面的合并分裂与迁移

### 伙伴页面的计算与页面合并

页面的合并发生在页面释放的时候。如果伙伴页也为空闲，则会对页面进行合并。

在伙伴系统的算法中，会将物理地址上相邻的页面作为互相的伙伴。如图中，在阶数为2的情况下，将四个连续的物理页算作伙伴。

![Alt text](../image/伙伴页.png)

buddy_idx 为伙伴页的页框号。

```c
static inline struct page *__page_find_buddy(struct page *page, unsigned long page_idx, unsigned int order)
{
    unsigned long buddy_idx = page_idx ^ (1 << order);

    return page + (buddy_idx - page_idx);
}
```

以 page_idx = 10 为例，假设此时是阶数为2，即四个页面连在一起。

```c

(1<<order) = 100

  1 0 1 0
^ 0 1 0 0
——————      异或得到下一个伙伴起始的页号为14
  1 1 1 0

  buddy_idx - page_idx得到本页对应的page结构到伙伴组的对应page结构地址的差距为4
  page + (buddy_idx - page_idx)
```

![Alt text](../image/页面合并.png)

### 页面的分裂

页面分裂发生在分配页面的时候。当需要的阶数大于被分配的空闲页面阶数，则会进行页面分裂。

```c
static inline void expand(struct zone *zone, struct page *page, int low, int high, struct free_area *area, int migratetype)
{
	unsigned long size = 1 << high;// 当前页面块的大小，2^high

	while (high > low) {
		area--;//移动到下一个更小阶的 free_area
		high--;//当前阶数减 1
		size >>= 1;//拆分页面块为更小的块（将块大小减半）
		VM_BUG_ON(bad_range(zone, &page[size]));
		list_add(&page[size].lru, &area->free_list[migratetype]);//将大页的后半部分放入阶数-1的free_area中
		area->nr_free++;
		set_page_order(&page[size], high);//设置拆分出的页面块的 order 信息，用于标记该块的阶数
	}
}
```

假设需要的阶数为1，分配到的阶数则为3。

![Alt text](../image/页面分裂.png)

### 页面回滚

#### fallbacks

`fallbacks` 是一个二维数组，其行表示当前的迁移类型。

列表示当该迁移类型的空闲页面不足时应回退的迁移类型顺序。每种迁移类型的空闲列表都包含不同类型的页面块。这些页面块的特性决定了它们能否被移动、回收或被保留。

```c
static int fallbacks[MIGRATE_TYPES][MIGRATE_TYPES-1] = {
    [MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE,MIGRATE_MOVABLE,   MIGRATE_RESERVE },
    [MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_RESERVE },
    [MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_RESERVE },
    [MIGRATE_RESERVE]     = { MIGRATE_RESERVE,     MIGRATE_RESERVE,   MIGRATE_RESERVE }, /* Never used */
};
```

其中一个一维数组代表一个回退顺序。

例如 MIGRATE_UNMOVABLE ，当无法移动的页面（MIGRATE_UNMOVABLE）用尽时，回退到 MIGRATE_RECLAIMABLE（可以回收的页面），然后是 MIGRATE_MOVABLE（可移动页面），最后是 MIGRATE_RESERVE（保留的页面块）。

### 页面迁移

页面迁移的时机：

* migrate_pages系统调用可以由用户根据情况进行页迁移

* kcompact内核线程：每个内存节点都会创建一个kcompactd内核线程，名称为kcompactd，每个节点都由一个kcompactd线程用于内存规整

* 内存热插拔：内存下线时，需要将该内存迁移到另外一个节点 防止数据丢失。

* move_pages:为另外一个系统调用，用于将指定进程的页面迁移到新节点。

* 系统长时间运行之后，可以通过sys和proc进行手动规整：

  * /proc/sys/vm/compact_memory：用于对当前系统所有进程的内存进行规整
  * sys/devices/system/node/node/compact： 用于手动指定单个节点进行内存规整。

* 当系统物理内存处于较低min watermark时，会通过__alloc_pages_direct_compact直接触发内存规整。

* 当进程在numa节点中发生迁移，会触发numa balance，将物理内存迁移到对应节点中。

* 当cma are中内存被move 类型内存占有，进行cma申请连续物理内存是会触发物理页迁移。

* get_user_pages类似函数申请内存时，对cma are进行检查有可能会触发物理页迁移。

* 当内核配置CONFIG_MEMORY_FAILURE，内存处理过程中如果出现memory failed 会进行页迁移