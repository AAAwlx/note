以下是一些在不同场景下保证存储操作两步之间原子性的方法：

**一、数据库事务（针对关系型数据库）**
1. **ACID特性**
   - 关系型数据库遵循ACID原则，其中原子性（Atomicity）确保了事务中的所有操作要么全部成功，要么全部失败。
   - 例如在一个银行转账的场景中，从一个账户扣款和向另一个账户收款这两个操作被视为一个事务。如果在这个过程中出现任何错误（如网络中断、数据库故障等），数据库会回滚到事务开始之前的状态，保证数据的一致性。
2. **使用事务语句**
   - 在SQL中，可以使用`BEGIN TRANSACTION`、`COMMIT`和`ROLLBACK`语句来明确地定义一个事务的范围。
   - 例如：
   ```sql
   BEGIN TRANSACTION;
   -- 第一步操作，如更新账户A的余额
   UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
   -- 第二步操作，如更新账户B的余额
   UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
   COMMIT;
   ```
   - 如果在这两个`UPDATE`操作之间出现错误，执行`ROLLBACK`语句就可以撤销这两个操作。

**二、文件系统操作（针对文件存储）**
1. **文件锁**
   - 许多操作系统提供了文件锁机制。例如在Unix/Linux系统中，可以使用`fcntl`函数对文件进行加锁操作。
   - 当一个进程对文件进行第一步操作时，它可以对文件加排他锁（写锁），这样其他进程就不能对该文件进行读写操作，直到该进程完成第二步操作并释放锁。
   - 这样可以保证在这两个操作期间，文件的内容不会被其他进程意外修改，从而确保原子性。
2. **日志先行（Write - Ahead Logging）**
   - 在一些文件系统或数据库系统中，采用日志先行的策略。
   - 在执行第一步操作之前，先将操作的相关信息记录到日志文件中。如果第二步操作失败，可以根据日志文件中的记录进行回滚操作，以保证数据的一致性。

**三、分布式系统中的原子性保证**
1. **分布式事务协议**
   - 如两阶段提交（2PC）协议。
   - 在一个涉及多个节点的存储操作中，协调者节点首先向所有参与者节点发送准备请求（第一阶段）。如果所有参与者节点都准备好执行操作，协调者节点再发送提交请求（第二阶段）。如果在第一阶段有任何一个节点无法准备好，协调者节点就会发送回滚请求，使得所有已经准备好的节点都回滚到操作之前的状态。
   - 不过2PC存在一些缺点，如同步阻塞、单点故障等问题，所以又有三阶段提交（3PC）等改进协议。
2. **基于消息队列的最终一致性**
   - 将存储操作的两步作为两个消息发送到消息队列中。
   - 消息队列保证消息的有序性和可靠性传递。接收方按照顺序处理这两个消息，如果在处理过程中出现错误，可以通过重试机制或者人工干预来保证最终的一致性。这种方式不能保证严格的原子性（即操作要么全部成功要么全部失败），但可以达到最终一致的效果，在一些对实时性要求不是特别高的分布式系统中比较常用。