# 8086汇编

硬件基础

### dos环境的构建

1.安装dosbox

2.安装masm编译器

3.编写完成后保存为.asm格式的文件

4.挂载

mount c c:/home/wlx

编译：masm 文件名

链接：link 程序名

运行：直接

## 寄存器

寄存器的概念：cpu中用来存储数据的单元 

#### 储存方式：

每个寄存器均为16位，可以看作两个八位的寄存器使用。

AX可以分为AH和AL。BX，CX，DX同理。H代表高八位，L代表低八位。

一个字为两位，由两个字节组成。注意区分两者的不同

#### 寻址方式：

8086CPU共有20位地址总线，一次可传送20位地址。但8086cpu为16位结构，为了增强寻址能力，采用16位段地址加四位偏移地址的方式。由十六位段地址加上四位偏移地址构成物理地址

##### 更加多样的寻址方式

[bx+si+idata]，该方式可用bx来表示二维数组中行的地址，si则是表示列的地址。与C语言中数组的表示方式类似。也可以此表示结构体，bx确定结构体的位置，idata确定结构体中的某一项，si确定项中具体的某个元素。

#### 段与段寄存器：

数据段寄存器：ds存放程序中用到的数据

代码段寄存器：cs存放代码文本

赋加段寄存器：es

堆栈寄存器：ss自行划分的堆栈区内存

堆栈指针寄存器：sp指向栈顶

指令指针寄存器：ip

[ ]表示该段地址，( )表示该地址上存储的值

Debug的功能

### 赋值与四则运算

### div

除法指令，使用时被除数默认为ax与dx中存储的数据。，其后只跟除数。

除数分为16位与8位两种。若是八位，则对应的被除数有16位存在ax中，商存在AL中，余数存在AH中。若为16位则对应32位，默认存在dx和ax之中，商存在ax中，余数存在dx中。

### mov

```
mov ax，1000;#将后者的值赋给前者
```

### add与sub

将前者与后者相加或相减，并将值存入前者

## 流控制语句

### offset操作符

获取指令在代码文本段中的标号。

如：mov ax , offset star （该句为代码段中的第一句，标号为0）相当于 mov ax , 0

示例代码

```
amusse cs:code
codesg segment
s:mov ax,bx
  mov
```

### jmp

后加地址，意为跳到代码文本的某一段去执行。

可以修改IP也可同时修改CS和IP

jmp short 标号 段内短转移，短转移最多转移128字节

jmp near ptr 近转移

jmp far ptr段间转移

### jcxz

如果cx=0,则转到标号处执行。当cx！=0时则什么也不做

该指令可看作c语言中的if指令

示例如下

```c
#include<stdio.h>
int main()
{
    int b=0,c;
    c=b;
    if(c){
        b++;
    }
    return ;
}
```

汇编

```vb
assume cs:codesg
codesg segment
start:mov ax 2000H
	  mov bx,0
	s:mov cx ,[bx]
      inc bx
      jmp short s
   ok:mov dx,bx
      mov ax,4c00H
      int 21H
codesg end
end start
```

两段代码的作用相似

### [bx]与loop

#### 段前缀：

将一片连续地址上的单元相加或做其他运算时，容易出现将一个地址误以为一个数字的问题。这时应该在地址前加上一个表示段的标记如ds：[0]即为数据段上的第一个位置

cpu在loop指令执行时要进行的操作

1.(cx)=(cx)-1

2.判断cx是否为0，若不为0则转至标号处执行程序，若为0则向下执行

类似于c语言中的while循环

#### 多重循环：

当需要多重循环时就需要多个来暂时存储循环计数器。但loop只有一个cx寄存器。这时我们需要将外层循环的次数用栈来暂时存储。并将cx设置为内层循环的次数。每次外到层时再将栈中的数据出栈恢复cx

## 栈

### push与pop

入栈与出栈。在汇编中可以自由分配栈区的大小与位置，但这样自由的模式十分危险，乱用内存容易造成系统的崩溃。使用时一定要多加小心。

栈是向下增长的

### div

除法指令，使用时被除数默认为ax与dx中存储的数据。，其后只跟除数。

除数分为16位与8位两种。若是八位，则对应的被除数有16位存在ax中，商存在AL中，余数存在AH中。若为16位则对应32位，默认存在dx和ax之中，商存在ax中，余数存在dx中。

### mul

### nop

无操作指令，常用于延迟执行或者是填充内存空间  

## 逻辑运算

### and与or

and按位与，or按位或

## 汇编程序格式

```c
assume cs:main
 
main segment#段名
 
start :
mov ax,2
add ax,ax
add ax,ax
 
mov ax,4c00H#两处特殊中断退出运行
int 21H
 
main ends#该段的结尾
 
end start#程序结尾
```

### 包含多个段的程序

示例

### 字符数据

db ‘字符串’

### 数字数据

dw 数字

### 双字型数据

dd用来定义双字型数据

在程序最前端可以使用assume这一词语假定，将数据代码段放入不同段

```c
assume cs:main ds:data ss:stack#意为将mian函数放入代码段，data数据放入数据段
```

### dup

可以使某段数据重复多次被储存在寄存器中

如 dw 2 dup（1,2,3,4,5）相当于

dw 1,2,3,4,5

dw 1,2,3,4,5

## 函数的使用

### call指令

作用：调用函数

实质：流程的转移

先将当前的IP/IP+CS入栈

然后跳转到带有标号的位置执行命令

仅为call标号为段内转移

call far ptr标号为段间转移IP与CS都入栈

call ward ptr将地址保存在内存中，使用时先将当前地址入栈，在从内存中读取地址跳到该地址

### ret指令

作用：当函数中的语句执行完之后返回到主函数中

实质：从栈中取出栈顶的存放的地址，并跳转到该处执行

示例

```v
assume：cs:codegs ss:stack
code segment
	mov ax 4c00h
	int 21h
start:mov ax ,stack
      mov ss ,ax
      mov sp,16
      mov ax,0
      push ax;
      ret
codesg ends
end start
```

该段代码通过将0入栈的方式使其跳转到中断语句处退出程序

### 调用函数
